## 表达式和运算符
数组直接量中元素列表逗号之间的元素可以省略，填充`undefined`。但是元素列表结尾处可以留下单个逗号，这时并不会创建一个新的值为`undefined`对元素。

```Javascript
var arr1 = [1,,,5]  // [1, undefined, undefined, 5]
var arr2 = [1,,,5,] // [1, undefined, undefined, 5]
arr1 == arr2  //false 对象内容相同但是并没有指向同一个对象
```
***
Javascript为属性访问定义了两种语法：`expression . identifier` 和 `expression [ expression ]`.  
`.identifier`写法简单，但是只适用于属性名称为合法的标识符，并且需要知道要访问的属性的名字。如果属性名称是一个保留字或者包含空格和标点符号，或者是一个数字（for array），则必须使用方括号的写法。当属性名称通过运算得到而不是固定的时候，也必须使用方括号。

***
Javascript中所有数字都是浮点型`5/2 = 2.5`
`%`结果符号与第一个操作符的符号相同

```Javascript
5 % 2 = 1
5 % -2 = 1
-5 % 2 = -1
```
`+`转换规则优先考虑字符串连接，如果其中一个操作数是字符串或者转换为字符串的对象，另一个操作符将转换为字符串，进行字符串的链接。其他算数运算符则都转换为数字进行操作，若无法转化为数字则转换为`NaN`

```Javascript
1 + 2          // => 3: 加法
"1" + "2"      // => "12": 字符串连接
"1" + 2        // => "12": 数字转换为字符串后进行字符串连接
1 + {}         // => "1[Object Object]": 对象转换为字符串后进行字符串连接
true + true    // => 2: 布尔型转换为数字后进行加法

2 + null       // => 2: null转换为0后做加法
2 + undefined  // => NaN: undefined 转换为NaN后做加法

1 + 2 + "3"    // => "33"
1 + (2 + "3")  // => "123"
```
`+`作为1元加法运算符时把操作数转换为数字（或者NaN）并返回。 
`++`并不是总和`x+=1`完全一样，`++`运算符从不进行字符串连接操作，它总是会将操作符转换为数字并增加1，如果`x`是字符串`“1”`，`++x`的结果时数字`2`，而`x+1`是字符串`"11"`

位运算符(`&`,`|`,`^`,`~`,`<<`.`>>`,`>>>`)要求它的操作数为整数，这些整数表示为32位整形而不是64位浮点型。位运算符会将`NaN`,`Infinity`和`-Infinity`都转换为0

---
Javascript中对象的比较是引用的比较，而不是值的比较。对象只和其本身相等，和其他任何对象都不等，即使其他对象和该对象具有完全相同的属性，属性名和值。   
`NaN`和其他任何址都不想等，包括它本身`NaN !== NaN NaN; != NaN`可以通过`x!==x`来判断`x`是否为`NaN`   
比较运算符（`>`,`<`,`>=`,`<=`）碰到`NaN`时均返回false   
 
---
逻辑表达式`&&`和`||`返回的是某一个操作数的值。并不一定返回`true` or `false`   
for example `&&` 运算符先判断左侧操作数的值，如果左侧表达式的计算结果为假，那么整个表达式一定为假，此时返回左操作数的值。若左操作数为真，返回右操作数的值。   
`!`总是返回`true`或者`false`,它会先将操作数转换为布尔值，再求反返回。可以使用`!!x`来获取`x`的等价布尔值

---
`eval()`只有一个参数，如果传入的参数不是字符串，**直接返回这个参数**，如果传入的参数是字符串，将该字符串当成Javascript的表达式进行编译。**Note：它使用了调用它的变量作用域环境**。   
通过别名调用`eval()`时，`eval()`会讲字符串当成顶层的全局代码来执行。   
直接调用`eval()`时，它总是在调用它的上下文作用域内执行，其他间接调用则使用全局对象作为其上下文作用域，且无法读、写、定义局部变量和函数。

```Javascript
var geval = eval;                     // 使用别名调用eval将是全局eval
var x = "global", y = "global";       // 定义两个全局变量
function f() {                        // 函数内执行局部eval
	var x = "local";                  // 定义局部变量 
	eval("x += 'changed';");          // 直接eval更改了局部变量的值
	return x;                         // 返回更改后的局部变量
}
function g() {                        // 函数内执行了全局eval
	var y = "local";                  // 定义局部变量
	geval("y += 'changed';");         // 间接eval更改了全局变量的值
	return y;                         // 返回未更改的局部变量
}
console.log(f(), x);                 // "localchanged global"
console.log(g(), y);                 // "local globalchanged"
```
全局`eval`的这些行为不仅处于代码优化器的需要而做出的一种折中方案，它实际上也是一种非常有用的特性，允许我们执行那些对上下文没有任何以来的全局脚本代码。   
在严格模式下，`eval`执行的代码可以查询或更改局部变量，但是不能在局部作用域中定义新的变量或者函数。不用使用别名覆盖。

---
##### 任意值在typeof运算后的返回值
|x | typeof x|
----|----------
|undefined|"undefined"|
|null|"object"
true或false|“boolean"
任意数字或NaN|"number"
任意字符串| "string"
任意函数|"function"
任意内置对象(非函数) | "object"
任意数组对象|由编译器个字实现的字符串，但不是"undefined","boolean","number"或"string"

